{"name":"Alice","tagline":"","body":"## ALICE: Application-Level Intelligent Crash Explorer\r\n\r\nThis is a user documentation of the ALICE tool, which can be used to\r\ndiscover “crash vulnerabilities” in applications. Crash vulnerabilities\r\nare problems that get exposed by a sudden power loss or system crash\r\nwhile the application is running, and the application cannot recover\r\ncorrectly after rebooting the machine. ALICE focuses on single-node\r\napplications that run atop file systems. ALICE is different from similar\r\ntools in that it aims to find vulnerabilities that might occur across\r\nall file systems, including future ones. ALICE is also unique in\r\ntargeting vulnerabilities associated with different source-code lines of\r\nthe application, instead of checking the application’s correctness atop\r\narbitrarily (or systematically, but less useful) simulated crash\r\nscenarios. ALICE is designed to be extensible: both how it checks\r\ndifferent source lines, and the combined behavior it assumes of\r\nunderlying file systems, can be customized. The ALICE tool is a\r\nby-product of a research project\r\n([http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html](http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html))\r\nin the University of Wisconsin-Madison.\r\n\r\n## Chapter 1: Installation\r\n\r\nALICE was tested to work on Ubuntu-12.02, and should be expected to work\r\non similar (i.e., Linux-like) operating systems. The following are\r\nspecific requirements:\r\n\r\n 1. Python-2.7, as the default version of python invoked via\r\n    /usr/bin/env python.\r\n 2. Standard software build tools, such as gcc and GNU Make.\r\n 3. The libunwind libraries, installable in Ubuntu-12.02 using apt-get\r\n    install libunwind7.\r\n\r\nThe following are the steps to install ALICE:\r\n\r\n 1. Download the most recent source-code tarball of ALICE, and untar it.\r\n    This should produce a directory named alice.\r\n 2. Set the environmental variable ALICE_HOME to point to the alice\r\n    directory (i.e., the untared directory). For example, this can be\r\n    done by adding the line export ALICE_HOME=/wherever-untarred/alice\r\n    to your .bashrc file.\r\n 3. Set the PATH environmental variable to include the alice/bin\r\n    directory. For example, this can be done by adding the line export\r\n    PATH=$PATH:/wherever-untarred/alice/bin to your .bashrc file.\r\n 4. Install the alice-strace tracing framework by moving into the\r\n    alice/alice-strace directory, and running ./configure; make; make\r\n    install;\r\n\r\n## Chapter 2: Basic Usage\r\n\r\nThe typical workflow for using ALICE has two steps. First, an\r\napplication workload is run, and a trace of its activities are recorded.\r\nSecond, ALICE is given this trace and a checker script (explained\r\nlater); ALICE explores the trace and displays discovered\r\nvulnerabilities. This documentation explains the typical usage of ALICE\r\nby using a toy application.\r\n\r\n#### Toy application\r\n\r\nThe toy application can be found in alice/example/toy/toy.c; the reader\r\nis encouraged to go through it. The application does the following:\r\n\r\n 1. It updates a file called file1, changing the contents of the file\r\n    from “hello” to “world”. The update is done using a typical “write\r\n    to temporary file and rename” sequence, so that the contents are\r\n    updated atomically. Immediately after updating, the application\r\n    prints a message to the user’s terminal (the user can then\r\n    supposedly assume that the file has been updated, and that the file\r\n    will contain “world” even if a power loss happens).\r\n 2. It creates two links to the file, link1 and link2. The (imaginary)\r\n    semantics of the toy application require both these links to be\r\n    created atomically (i.e., if a power loss happens, either both links\r\n    exist or neither do not).\r\n\r\n#### Step 1: Running the application and recording a trace\r\n\r\nA script that runs the application and records a trace, along with all\r\ninitialization setup, can be found in\r\nalice/example/toy/toy_workload.sh; the reader is encouraged to go\r\nthrough it.\r\n\r\nTo perform Step 1, two directories are needed. The first, the workload\r\ndirectory, is where the files of the application will be stored. The\r\napplication, as it runs, will modify the workload directory and its\r\ncontents. For the toy application, this is the place where file1, link1,\r\nand link2, are placed. The toy_workload.sh script first creates the\r\nworkload directory, workload_dir, and then initializes it with the file\r\nfile1 containing “hello”.\r\n\r\nThe other needed directory, traces directory is for storing the\r\n(multiple) traces that are recorded as the application is run. The\r\ntoy_workload.sh script next creates this directory, traces_dir. After\r\nsetting up the workload directory and the traces directory, the\r\ntoy_workload.sh script does a few more initialization things: compiling\r\nthe toy.c application, and cding into workload_dir so that the toy\r\napplication can be run within there.\r\n\r\nThe toy_workload.sh script finally runs the application and records\r\ntraces, by issuing the following command:\r\n\r\nalice-record --workload_dir . \\ \r\n --traces_dir ../traces_dir \\ \r\n ../a.out\r\n\r\nIf the reader is familiar with the strace utility, the above command is\r\nsimilar to an invocation of strace: alice-record is a script that\r\nrecords traces, while ../a.out is the actual application to be run (the\r\nprocess and all subprocesses of ../a.out are traced, similar to strace\r\nwith the -ff option). The alice-record script requires two mandatory\r\narguments: the workload directory and the traces directory (alice-record\r\ntakes one more optional argument, --verbose, to control verbosity).\r\n\r\n#### Step 2: Supply ALICE with the trace and the checker, and get back\r\nlist of vulnerabilities\r\n\r\nStep 2 requires the user to supply ALICE with a checker script. The\r\nchecker script will be invoked multiple times by ALICE, each invocation\r\ncorresponding to a (simulated) system crash scenario that could have\r\nhappened while the application was running in Step 1. During each\r\ninvocation, the checker script will be given a directory that reflects\r\nthe state of the workload directory if the (simulated) crash had really\r\nhappened. If the given crashed-state workload directory has an expected\r\n(i.e., consistent) set of files, the checker script should exit with\r\nstatus zero, and should exit with a non-zero status otherwise.\r\n\r\nALICE supplies the checker script with two command-line arguments. The\r\nfirst is the path to the crashed-state workload directory. The second\r\ncommand-line argument to the checker script is the path to an stdout\r\nfile. The stdout file contains all the messages that had been printed to\r\nthe user’s terminal at the time of the crash (corresponding to the\r\nsupplied crashed-state workload directory), and can be used by the\r\nchecker to check for durability, as explained below. Note that the\r\ncrashed-state workload directory supplied by ALICE might differ from the\r\noriginal workload directory in Step 1. Hence, for applications that\r\nexpect the absolute path of the contents within the workload directory\r\nto not have changed (a small subset of applications in our experience),\r\nthe checker script needs to move the supplied directory to the original\r\ndirectory, and then operate atop the original directory.\r\n\r\nThe checker script for the toy application can be found in\r\nalice/example/toy/toy_checker.py, and the reader is encouraged to go\r\nthrough it. The script first changes the current working directory into\r\nthe crashed-state directory supplied by ALICE, and reads all the\r\nmessages printed in the terminal at the time of the crash by reading the\r\nstdout file supplied by ALICE. If the application has printed the\r\n“Updated file1 to world” message, the checker script makes sure that\r\nfile1 contains “world”; otherwise, the checker script makes sure that\r\nfile1 contains either “hello” or “world”. The checker script then makes\r\nsure that either link1 and link2 are both present, or are both not\r\npresent. If any of the checked conditions do not hold, the checker\r\nscript results in an assertion failure, thus exiting with a non-zero\r\nstatus (and thus informing ALICE that the application will fail if the\r\nsimulated crash scenario happens in real).\r\n\r\nAfter writing the checker script, the user can invoke the alice-check\r\nscript to actually run ALICE and get the list of vulnerabilities. The\r\nreader is encouraged to run the following command from within the\r\nalice/example/toy directory, to get a list of vulnerabilities discovered\r\nin the toy application (after running toy_workload.sh first).\r\n\r\nalice-check --traces_dir=traces_dir --checker=./toy_checker.py\r\n\r\nThe alice-check script has the following arguments:\r\n\r\n traces_dir\r\n  ~ Mandatory. The traces directory, from Step 1.\r\n checker\r\n  ~ Mandatory. The checker script.\r\n threads\r\n  ~ Optional, default is 4. ALICE invokes checker scripts parallely,\r\n    each checker script given a separate crashed-state directory to work\r\n    on. Some applications do not allow multiple simultaneous\r\n    invocations, and might require this option to be set to 1.\r\n debug_level\r\n  ~ Optional, default is 0. Verbosity of warnings, can be 0, 1, or 2.\r\n ignore_mmap\r\n  ~ Optional, default is False. The current version of ALICE does not\r\n    trace mmap-writes, and cannot correctly work with application\r\n    workloads that use memory mapping to modify relevant files (see\r\n    caveats and limitations). If the recorded trace during Step 1\r\n    involves a writeable mmap() to a seemingly relevant file,\r\n    alice-check aborts execution by default. However, some application\r\n    workloads use mmap() only on files that are irrelevant to crash\r\n    consistency, for example to implement a shared-memory lock dealing\r\n    with multi-process concurrency synchronization. This option can be\r\n    set to True if the user is sure that the mmap()s observed while\r\n    running the application workload are irrelevant to finding crash\r\n    vulnerabilities. Some database applications use mmap() for\r\n    concurrency control, even when configured not to use mmap() for\r\n    otherwise accessing files, and require this option.\r\n\r\n#### Understanding ALICE’s output\r\n\r\nALICE first outputs a list of list of the logical operations that form\r\nthe update protocol used by the application workload invoked in Step 1.\r\nThe logical operations displayed is similar to a system-call trace,\r\nexcept that it is easier to understand, for example substituiting file\r\nnames instead of file descriptor numbers.\r\n\r\nALICE then displays any discovered vulnerabilities. Vulnerabilities are\r\ndisplayed in two ways: dynamic vulnerabilities, relating to different\r\noperations in the update protocol, and static vulnerabilities, relating\r\nto source-code lines. The proper display of static vulnerabilities\r\nrequires the originally traced application to have debugging symbols;\r\nalso, ALICE associates each logical operation to one of the stack frames\r\nin the logical operation’s stack trace to display static\r\nvulnerabilities, and this association can sometimes be faulty.\r\n\r\n## Chapter 3: Customizing, Extending, and Hacking\r\n\r\nALICE is designed to be extensible. The current version of ALICE strips\r\noff many features that were previously implemented, in hopes that a\r\nsmaller code base promotes extensions. However, the current version is\r\nalso not sufficiently commented, and does not follow some good coding\r\npractices; a well-commented version of the software might be released in\r\nthe future if users shows interest.\r\n\r\nTo extend ALICE, readers are required to go through our publication\r\n([http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html](http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html))\r\nto understand ALICE’s design and philosophy. Note that there is some\r\nterminology difference between the publication and ALICE’s source code;\r\nin particular, logical operations discussed in the publication\r\ncorrespond to micro operations in the source code, while micro\r\noperations in the publication correspond to disk operations in the\r\nsource code.\r\n\r\nALICE’s default exploration strategy, which investigates the ordering\r\nand atomicity of each system call and reports any associated\r\nvulnerabilities, is coded in alice/alicedefaultexplorer.py, and can be\r\neasily changed. The alicedefaultexplorer.py code is complicated since it\r\ndisplays static vulnerabilities and invokes checkers in multiple\r\nthreads. A functionally equivalent exploration strategy can be simpler.\r\n\r\nALICE’s default APM is coded in alice/alicedefaultfs.py, and can be\r\neasily changed. The alicedefaultfs.py code is complicated since it\r\nmodels a file system that can be configured to split file operations in\r\ndifferent granularities. A functionally equivalent file system (with a\r\nsingle granularity) can be simpler.\r\n\r\nOther than the extensions discussed till now, users might try to add\r\nsupport for more system calls, file attributes, symbolic links, or other\r\nsuch details, in ALICE. Relevant to these, the _aliceparsesyscalls.py\r\nscript contains code that converts system calls into logical operations,\r\nwhile the replay_disk_ops() function from the alice.py script contains\r\ncode that re-constructs a directory from a given list of micro-ops.\r\n\r\n## Chapter 4: Caveats and Limitations\r\n\r\nALICE is a safe, but not a complete tool. That is, the application might\r\nhave additional vulnerabilities than those discovered and reported.\r\nALICE is thus not aligned towards comparing the correctness of different\r\napplications; specifically, any comparisons when not using equivalent\r\nworkloads and checkers can easily produce confusing, wrong inferences.\r\nAlso, any vulnerability displayed by ALICE might already be known to an\r\napplication developer: the application documentation might explicitly\r\nrequire that the underlying file system not behave in those ways that\r\nwill expose the vulnerability, or might simply not provide those\r\nguarantees that are being checked by the checker.\r\n\r\nThe default file-system model (APM) used by ALICE is designed to also\r\nfind vulnerabilities that can get exposed by future file systems; some\r\ncrash scenarios that are possible with the default model do not happen\r\nin common current file systems. Also, ALICE’s output (a list of\r\nvulnerabilities) is only designed to show the number of source lines\r\nthat require ordering or atomicity. It is thus erraneous to directly\r\ncorrelate the number of vulnerabilities shown by ALICE with current\r\nreal-world impact.\r\n\r\nALICE does not currently attempt to deal with any file attributes\r\n(including modification time) other than the file size, or with the\r\nFD_CLOEXEC and O_CLOEXEC facilities. If the application’s logic (that\r\nis invoked in the workload and the checker) depends on these, ALICE’s\r\noutput is probably wrong. Support for a few rarely-used system calls is\r\nalso lacking; warning or error messages are displayed by ALICE if the\r\napplication workload had invoked such calls. The situation for symlinks\r\nis similar; while the current version of ALICE attempts to support them\r\nslightly, if the application logic depends on symlinks, ALICE’s output\r\nmight be wrong.\r\n\r\nThe current version of ALICE also does not support tracing memory-mapped\r\nwrites; applications that use such writes as a part of their (relevant)\r\nupdate protocol cannot use ALICE. Note that a version of ALICE used in\r\nour published research paper\r\n([http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html](http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html))\r\ntraced memory-mapped writes, but support was removed in the interest of\r\ndistributability.\r\n\r\nAdding support for file attributes, CLOEXEC, symlinks, and mmap() writes\r\ndoes not require any changes to the design of ALICE, and might be done\r\nin future versions if users deem them helpful.\r\n\r\n## Chapter 5: Credits, Acknowledgements, and Contact Information\r\n\r\nThanumalayan Sankaranarayana Pillai, Vijay Chidambaram, Ramnatthan\r\nAlagappan, and Samer Al-Kiswany were involved in various aspects of\r\ndesign and testing of the ALICE tool. Thanumalayan Sankaranarayana\r\nPillai (madthanu@cs.wisc.edu) is the primary author of the tool, and\r\nmight serve to be the best contact for bug reports, feature requests, or\r\nother general discussions. Ramnatthan Alagappan extensively tested the\r\ntool, and Vijay Chidambaram also wrote a part of the code.\r\n\r\nThe ALICE tool is a by-product of a research project\r\n([http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html](http://research.cs.wisc.edu/adsl/Publications/alice-osdi14.html))\r\nin the University of Wisconsin-Madison, and due credit must be given to\r\nall parties who were involved in or contributed to the project.\r\n\r\nThe alice-strace tracing framework is a slight customization of the\r\nstrace tool\r\n([http://sourceforge.net/projects/strace/](http://sourceforge.net/projects/strace/)),\r\nalong with some code adapted from strace-plus\r\n([https://code.google.com/p/strace-plus/](https://code.google.com/p/strace-plus/)).\r\nCredits must be given to the authors and contributors of strace and\r\nstrace-plus.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}